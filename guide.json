Successfully parsed JSON:
[36m{[0m
	[94m"footer"[0m[37m: [0m[36m{[0m
		[94m"completionText"[0m[37m: [0m[31m"Mark this topic as mastered"[0m[37m,[0m
		[94m"message"[0m[37m: [0m[31m"Learning journey completed! üéâ"[0m
	[36m}[0m[37m,[0m
	[94m"meta"[0m[37m: [0m[36m{[0m
		[94m"author"[0m[37m: [0m[31m"sel-mlil"[0m[37m,[0m
		[94m"description"[0m[37m: [0m[31m"Master network programming with sockets and efficient I/O multiplexing using poll"[0m[37m,[0m
		[94m"difficulty"[0m[37m: [0m[31m"advanced"[0m[37m,[0m
		[94m"lastUpdated"[0m[37m: [0m[31m"2025-09-26"[0m[37m,[0m
		[94m"tags"[0m[37m: [0m[36m[[0m
			[31m"networking"[0m[37m,[0m
			[31m"sockets"[0m[37m,[0m
			[31m"poll"[0m[37m,[0m
			[31m"server programming"[0m[37m,[0m
			[31m"I/O multiplexing"[0m
		[36m][0m[37m,[0m
		[94m"title"[0m[37m: [0m[31m"Sockets & Poll"[0m
	[36m}[0m[37m,[0m
	[94m"navigation"[0m[37m: [0m[36m[[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üéØ"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"hook"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m0[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"The Hook"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"‚öôÔ∏è"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"mechanics"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m1[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"How It Works"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üåç"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"examples"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m2[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Real Examples"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üõ†Ô∏è"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"practice"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m3[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Do This Now"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"‚ö†Ô∏è"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"warnings"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m4[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Avoid These"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üîó"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"connections"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m5[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Connections"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üéØ"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"test"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m6[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Test Yourself"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"emoji"[0m[37m: [0m[31m"üìà"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"growth"[0m[37m,[0m
			[94m"sectionIndex"[0m[37m: [0m[33m7[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"Level Up"[0m
		[36m}[0m
	[36m][0m[37m,[0m
	[94m"sections"[0m[37m: [0m[36m[[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"<strong>What is this?</strong><br>Sockets are endpoints for communication between processes over a network or within the same machine. <code>poll</code> lets you efficiently wait for multiple sockets to become ready for reading, writing, or errors."[0m[37m,[0m
					[94m"html"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"<strong>Why care?</strong><br>Essential for building <strong>servers or networked applications</strong> to handle multiple clients without busy-waiting or blocking threads."[0m[37m,[0m
					[94m"html"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"<strong>Mental model:</strong><br>Think of sockets like <strong>phone lines</strong>, each connecting to a friend. <code>poll</code> is like a receptionist telling you which lines are ringing, so you don't check each phone constantly."[0m[37m,[0m
					[94m"html"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üéØ"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"hook"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"hook"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"THE HOOK"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Socket Fundamentals"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Sockets are communication endpoints that provide a uniform interface for network programming. Understanding their types, lifecycle, and configuration is crucial for building robust servers."[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Socket Types & Address Families"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// TCP socket - reliable, connection-oriented
int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);

// UDP socket - unreliable, connectionless
int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);

// Unix domain socket - local inter-process communication
int unix_sock = socket(AF_UNIX, SOCK_STREAM, 0);

// IPv6 socket
int ipv6_sock = socket(AF_INET6, SOCK_STREAM, 0);"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Socket Lifecycle"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>Creation:</strong> <code>socket()</code> - Creates a new socket endpoint"[0m[37m,[0m
						[31m"<strong>Configuration:</strong> <code>setsockopt()</code> - Set socket options (reuse addr, timeouts, etc.)"[0m[37m,[0m
						[31m"<strong>Binding:</strong> <code>bind()</code> - Associate socket with specific address/port"[0m[37m,[0m
						[31m"<strong>Listening:</strong> <code>listen()</code> - Mark socket as passive (server only)"[0m[37m,[0m
						[31m"<strong>Connection:</strong> <code>accept()</code>/<code>connect()</code> - Establish connections"[0m[37m,[0m
						[31m"<strong>Communication:</strong> <code>send()</code>/<code>recv()</code> - Exchange data"[0m[37m,[0m
						[31m"<strong>Cleanup:</strong> <code>close()</code> - Release resources"[0m
					[36m][0m[37m,[0m
					[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Critical Socket Options"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// Allow address reuse (prevents "Address already in use" errors)
int reuse = 1;
setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

// Set socket to non-blocking mode
int flags = fcntl(sock_fd, F_GETFL, 0);
fcntl(sock_fd, F_SETFL, flags | O_NONBLOCK);

// Set receive/send buffer sizes
int buf_size = 64 * 1024;  // 64KB
setsockopt(sock_fd, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));
setsockopt(sock_fd, SOL_SOCKET, SO_SNDBUF, &buf_size, sizeof(buf_size));

// Set timeouts
struct timeval timeout = {.tv_sec = 30, .tv_usec = 0};
setsockopt(sock_fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Poll Mechanics Deep Dive"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"<code>poll()</code> is a system call that monitors multiple file descriptors for I/O events. It's more scalable than <code>select()</code> and doesn't have the FD_SETSIZE limitation."[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Poll Structure & Events"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"struct pollfd {
    int fd;        // File descriptor to monitor
    short events;  // Events to watch for (input)
    short revents; // Events that occurred (output)
};

// Event types you can monitor:
// POLLIN     - Data available for reading
// POLLOUT    - Socket ready for writing
// POLLERR    - Error condition
// POLLHUP    - Hangup (connection closed by peer)
// POLLNVAL   - Invalid file descriptor
// POLLPRI    - Urgent data (out-of-band)
// POLLRDHUP  - Peer closed writing end (Linux-specific)"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Poll Timeout Strategies"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// Infinite timeout - wait forever
int ready = poll(fds, nfds, -1);

// No timeout - return immediately
int ready = poll(fds, nfds, 0);

// Specific timeout in milliseconds
int ready = poll(fds, nfds, 5000);  // 5 second timeout

// Handling timeout
if (ready == 0) {
    printf("Timeout occurred\n");
    // Handle timeout logic (heartbeat, cleanup, etc.)
} else if (ready < 0) {
    if (errno == EINTR) {
        // Interrupted by signal, usually safe to retry
        continue;
    }
    perror("poll failed");
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Combining Sockets & Poll"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"The power comes from using poll to efficiently manage multiple sockets without blocking or wasting CPU cycles."[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Server Architecture Pattern"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// Typical server structure
#define MAX_CLIENTS 1000
struct pollfd fds[MAX_CLIENTS + 1];  // +1 for server socket
int client_count = 0;

// Initialize server socket in fds[0]
fds[0].fd = server_fd;
fds[0].events = POLLIN;  // Listen for new connections

while (1) {
    int ready = poll(fds, client_count + 1, -1);
    
    // Check server socket for new connections
    if (fds[0].revents & POLLIN) {
        handle_new_connection();
    }
    
    // Check all client sockets
    for (int i = 1; i <= client_count; i++) {
        if (fds[i].revents & POLLIN) {
            handle_client_data(i);
        }
        if (fds[i].revents & POLLOUT) {
            handle_client_write(i);
        }
        if (fds[i].revents & (POLLHUP | POLLERR)) {
            handle_client_disconnect(i);
        }
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Governing Principles"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>Non-blocking everything:</strong> Use non-blocking sockets to prevent any operation from hanging the entire server."[0m[37m,[0m
						[31m"<strong>Event-driven architecture:</strong> React to events (data ready, connection closed) rather than polling continuously."[0m[37m,[0m
						[31m"<strong>Efficient resource management:</strong> One poll call handles hundreds or thousands of connections."[0m[37m,[0m
						[31m"<strong>Graceful degradation:</strong> Handle partial reads/writes and temporary failures elegantly."[0m[37m,[0m
						[31m"<strong>State management:</strong> Track connection state, pending operations, and cleanup requirements."[0m
					[36m][0m[37m,[0m
					[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"‚öôÔ∏è"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"mechanics"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"mechanics"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"HOW IT WORKS"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Complete Production-Ready Server"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Here's a comprehensive server implementation that handles all the edge cases you'll encounter in production:"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/poll.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_CLIENTS 1000
#define BUFFER_SIZE 4096
#define SERVER_PORT 8080

// Client connection state
typedef struct {
    int fd;
    char read_buffer[BUFFER_SIZE];
    char write_buffer[BUFFER_SIZE];
    size_t read_pos;
    size_t write_pos;
    size_t write_len;
    int wants_write;
} client_t;

client_t clients[MAX_CLIENTS];
struct pollfd fds[MAX_CLIENTS + 1];
int client_count = 0;"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Server Setup with Proper Error Handling"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"int setup_server() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        return -1;
    }
    
    // Enable address reuse to avoid "Address already in use" errors
    int reuse = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {
        perror("setsockopt SO_REUSEADDR");
        close(server_fd);
        return -1;
    }
    
    // Set to non-blocking
    int flags = fcntl(server_fd, F_GETFL, 0);
    if (flags < 0 || fcntl(server_fd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror("fcntl non-blocking");
        close(server_fd);
        return -1;
    }
    
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(SERVER_PORT);
    
    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(server_fd);
        return -1;
    }
    
    if (listen(server_fd, 128) < 0) {
        perror("listen");
        close(server_fd);
        return -1;
    }
    
    return server_fd;
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Handling New Connections with Edge Cases"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void handle_new_connection(int server_fd) {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        
        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &addr_len);
        
        if (client_fd < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // No more connections to accept
                break;
            }
            if (errno == EINTR) {
                // Interrupted by signal, retry
                continue;
            }
            perror("accept");
            break;
        }
        
        // Check if we have space for more clients
        if (client_count >= MAX_CLIENTS) {
            printf("Server full, rejecting connection\n");
            close(client_fd);
            continue;
        }
        
        // Set client socket to non-blocking
        int flags = fcntl(client_fd, F_GETFL, 0);
        if (flags < 0 || fcntl(client_fd, F_SETFL, flags | O_NONBLOCK) < 0) {
            perror("fcntl client non-blocking");
            close(client_fd);
            continue;
        }
        
        // Initialize client state
        clients[client_count].fd = client_fd;
        clients[client_count].read_pos = 0;
        clients[client_count].write_pos = 0;
        clients[client_count].write_len = 0;
        clients[client_count].wants_write = 0;
        
        // Add to poll array
        fds[client_count + 1].fd = client_fd;
        fds[client_count + 1].events = POLLIN;
        fds[client_count + 1].revents = 0;
        
        client_count++;
        printf("New client connected (fd=%d, total=%d)\n", client_fd, client_count);
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Handling Partial Reads/Writes"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void handle_client_read(int client_idx) {
    client_t *client = &clients[client_idx];
    
    while (1) {
        ssize_t bytes_read = recv(client->fd, 
            client->read_buffer + client->read_pos,
            BUFFER_SIZE - client->read_pos - 1,  // Leave space for null terminator
            0);
            
        if (bytes_read > 0) {
            client->read_pos += bytes_read;
            client->read_buffer[client->read_pos] = '\0';
            
            // Process complete messages (assuming line-based protocol)
            char *line_end;
            while ((line_end = strchr(client->read_buffer, '\n')) != NULL) {
                *line_end = '\0';
                
                // Echo the message back
                snprintf(client->write_buffer, BUFFER_SIZE, 
                    "Echo: %s\n", client->read_buffer);
                client->write_len = strlen(client->write_buffer);
                client->write_pos = 0;
                client->wants_write = 1;
                
                // Enable POLLOUT for this client
                fds[client_idx + 1].events |= POLLOUT;
                
                // Move remaining data to beginning of buffer
                size_t remaining = client->read_pos - (line_end - client->read_buffer + 1);
                memmove(client->read_buffer, line_end + 1, remaining);
                client->read_pos = remaining;
                client->read_buffer[client->read_pos] = '\0';
            }
            
            // Check if buffer is full
            if (client->read_pos >= BUFFER_SIZE - 1) {
                printf("Client buffer overflow, disconnecting\n");
                close_client(client_idx);
                return;
            }
            
        } else if (bytes_read == 0) {
            // Client disconnected gracefully
            printf("Client disconnected (fd=%d)\n", client->fd);
            close_client(client_idx);
            return;
            
        } else {
            // Error or would block
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // No more data available
                break;
            }
            if (errno == EINTR) {
                // Interrupted by signal, retry
                continue;
            }
            perror("recv");
            close_client(client_idx);
            return;
        }
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Handling Partial Writes"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void handle_client_write(int client_idx) {
    client_t *client = &clients[client_idx];
    
    while (client->write_pos < client->write_len) {
        ssize_t bytes_sent = send(client->fd,
            client->write_buffer + client->write_pos,
            client->write_len - client->write_pos,
            0);
            
        if (bytes_sent > 0) {
            client->write_pos += bytes_sent;
            
        } else if (bytes_sent == 0) {
            // Shouldn't happen with send(), but handle it
            printf("send() returned 0\n");
            close_client(client_idx);
            return;
            
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Socket buffer full, try again later
                return;
            }
            if (errno == EINTR) {
                // Interrupted by signal, retry
                continue;
            }
            if (errno == EPIPE) {
                // Broken pipe (client disconnected)
                printf("Broken pipe, client disconnected (fd=%d)\n", client->fd);
                close_client(client_idx);
                return;
            }
            perror("send");
            close_client(client_idx);
            return;
        }
    }
    
    // All data sent, disable POLLOUT
    if (client->write_pos >= client->write_len) {
        client->wants_write = 0;
        fds[client_idx + 1].events &= ~POLLOUT;
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Proper Client Cleanup"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void close_client(int client_idx) {
    if (client_idx < 0 || client_idx >= client_count) {
        return;
    }
    
    close(clients[client_idx].fd);
    printf("Closed connection (fd=%d)\n", clients[client_idx].fd);
    
    // Move last client to this position to avoid gaps
    if (client_idx < client_count - 1) {
        clients[client_idx] = clients[client_count - 1];
        fds[client_idx + 1] = fds[client_count];
    }
    
    client_count--;
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Main Event Loop with Signal Handling"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"int main() {
    int server_fd = setup_server();
    if (server_fd < 0) {
        exit(1);
    }
    
    printf("Server listening on port %d\n", SERVER_PORT);
    
    // Set up server in poll array
    fds[0].fd = server_fd;
    fds[0].events = POLLIN;
    fds[0].revents = 0;
    
    while (1) {
        // Poll with 1 second timeout for periodic tasks
        int ready = poll(fds, client_count + 1, 1000);
        
        if (ready < 0) {
            if (errno == EINTR) {
                // Interrupted by signal (SIGINT, etc.)
                printf("\nShutting down server...\n");
                break;
            }
            perror("poll");
            break;
        }
        
        if (ready == 0) {
            // Timeout - do periodic maintenance
            printf("Active connections: %d\n", client_count);
            continue;
        }
        
        // Check for new connections
        if (fds[0].revents & POLLIN) {
            handle_new_connection(server_fd);
        }
        
        // Check all client connections
        for (int i = 0; i < client_count; i++) {
            int poll_idx = i + 1;
            
            if (fds[poll_idx].revents & (POLLHUP | POLLERR | POLLNVAL)) {
                printf("Connection error/hangup (fd=%d)\n", clients[i].fd);
                close_client(i);
                i--; // Adjust index since we removed a client
                continue;
            }
            
            if (fds[poll_idx].revents & POLLIN) {
                handle_client_read(i);
                // Client might have been closed in handle_client_read
                if (i >= client_count) {
                    i--;
                    continue;
                }
            }
            
            if (fds[poll_idx].revents & POLLOUT) {
                handle_client_write(i);
            }
        }
    }
    
    // Cleanup
    close(server_fd);
    for (int i = 0; i < client_count; i++) {
        close(clients[i].fd);
    }
    
    return 0;
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üåç"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"examples"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"examples"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"REAL EXAMPLES"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Exercise 1: Basic Echo Server"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"action"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Goal:</strong> Build a server that echoes back everything clients send to it."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// Starter template - fill in the missing pieces
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/poll.h>
#include <netinet/in.h>
#include <errno.h>

int main() {
    // TODO: Create server socket
    // TODO: Set SO_REUSEADDR
    // TODO: Bind to port 8080
    // TODO: Listen for connections
    
    struct pollfd fds[10];
    int nfds = 1;
    
    // TODO: Initialize fds[0] with server socket
    
    while (1) {
        // TODO: Call poll() with proper parameters
        
        // TODO: Check for new connections on server socket
        
        // TODO: Check existing clients for data
        // TODO: Echo received data back to sender
        
        // TODO: Handle client disconnections
    }
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"Implement the missing TODO sections"[0m[37m,[0m
								[31m"Test with: <code>telnet localhost 8080</code>"[0m[37m,[0m
								[31m"Connect multiple telnet sessions simultaneously"[0m[37m,[0m
								[31m"Verify each client gets their own echo"[0m
							[36m][0m[37m,[0m
							[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Success criteria:</strong> Server handles 5+ concurrent clients without blocking."[0m[37m,[0m
							[94m"html"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Exercise 2: Chat Room Server"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"action"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Goal:</strong> Build a chat server where messages from one client are broadcast to all others."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// Chat server features to implement:
// 1. Client nicknames (first message sets nickname)
// 2. Broadcast messages to all connected clients
// 3. Join/leave notifications
// 4. Command support (/quit, /list, /help)

typedef struct {
    int fd;
    char nickname[32];
    char buffer[1024];
    size_t buffer_pos;
    int authenticated;
} chat_client_t;

void broadcast_message(const char *message, int sender_fd) {
    // TODO: Send message to all clients except sender
}

void handle_chat_command(chat_client_t *client, const char *message) {
    if (strncmp(message, "/quit", 5) == 0) {
        // TODO: Handle quit command
    } else if (strncmp(message, "/list", 5) == 0) {
        // TODO: List all connected users
    } else {
        // TODO: Broadcast regular message
    }
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"Implement client nickname system"[0m[37m,[0m
								[31m"Add message broadcasting to all clients"[0m[37m,[0m
								[31m"Handle line-based protocol (messages end with \n)"[0m[37m,[0m
								[31m"Add commands: /quit, /list, /help"[0m[37m,[0m
								[31m"Test with multiple telnet sessions"[0m
							[36m][0m[37m,[0m
							[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Exercise 3: HTTP File Server"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"action"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Goal:</strong> Build a basic HTTP server that serves static files."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// HTTP server requirements:
// 1. Parse HTTP request line (GET /path HTTP/1.1)
// 2. Serve files from ./public/ directory
// 3. Return 404 for missing files
// 4. Set proper Content-Type headers
// 5. Handle multiple concurrent requests

void parse_http_request(const char *request, char *method, char *path) {
    // TODO: Parse "GET /index.html HTTP/1.1"
}

void send_http_response(int client_fd, int status, const char *content_type, 
                       const char *body, size_t body_len) {
    char header[512];
    snprintf(header, sizeof(header),
        "HTTP/1.1 %d %s\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n",
        status, (status == 200) ? "OK" : "Not Found",
        content_type, body_len);
    
    // TODO: Send header and body
}

const char* get_mime_type(const char *filename) {
    // TODO: Return appropriate MIME type based on file extension
    // .html -> text/html
    // .css -> text/css
    // .js -> application/javascript
    // .png -> image/png
    // default -> text/plain
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"Create ./public/ directory with some HTML files"[0m[37m,[0m
								[31m"Implement HTTP request parsing"[0m[37m,[0m
								[31m"Add file serving with proper MIME types"[0m[37m,[0m
								[31m"Handle 404 errors gracefully"[0m[37m,[0m
								[31m"Test with web browser: <code>http://localhost:8080/</code>"[0m[37m,[0m
								[31m"<strong>Bonus:</strong> Add directory listing for folders"[0m
							[36m][0m[37m,[0m
							[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Exercise 4: Performance Testing"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"action"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Goal:</strong> Test your server's performance limits and identify bottlenecks."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"# Test tools to use:

# 1. Apache Bench (ab) - HTTP load testing
ab -n 10000 -c 100 http://localhost:8080/

# 2. wrk - Modern HTTP benchmarking tool
wrk -t4 -c100 -d30s http://localhost:8080/

# 3. Custom client for chat/echo servers
# Write a client that opens 1000 connections and sends messages

# 4. Monitor system resources
top -p $(pgrep your_server)
netstat -an | grep :8080 | wc -l  # Count connections
lsof -p $(pgrep your_server) | wc -l  # Count file descriptors"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"bash"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"Test with increasing number of concurrent connections"[0m[37m,[0m
								[31m"Measure: requests/second, memory usage, CPU usage"[0m[37m,[0m
								[31m"Find the breaking point (when errors start occurring)"[0m[37m,[0m
								[31m"Profile with <code>strace -c</code> to see system call usage"[0m[37m,[0m
								[31m"Compare poll() vs simple blocking accept()/recv()"[0m
							[36m][0m[37m,[0m
							[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Questions to answer:</strong> How many clients can your server handle? What's the bottleneck? Memory, CPU, or file descriptors?"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Exercise 5: Error Injection Testing"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"action"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"<strong>Goal:</strong> Test how your server handles various failure scenarios."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"# Failure scenarios to test:

# 1. Client sends partial data and disconnects
echo -n "GET /" | nc localhost 8080

# 2. Client connects but never sends data
nc localhost 8080
# (just connect, don't type anything)

# 3. Client sends huge amount of data
yes "A" | head -1000000 | nc localhost 8080

# 4. Many clients connect and disconnect rapidly
for i in {1..100}; do
    echo "test" | nc localhost 8080 &
done

# 5. Client sends invalid HTTP requests
echo -e "INVALID REQUEST\r\n\r\n" | nc localhost 8080"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"bash"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"Test each failure scenario above"[0m[37m,[0m
								[31m"Verify server doesn't crash or hang"[0m[37m,[0m
								[31m"Check for memory leaks with <code>valgrind</code>"[0m[37m,[0m
								[31m"Ensure server logs errors appropriately"[0m[37m,[0m
								[31m"Verify server continues handling other clients"[0m
							[36m][0m[37m,[0m
							[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Success Milestones"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>Beginner:</strong> Echo server handles 10+ concurrent clients"[0m[37m,[0m
						[31m"<strong>Intermediate:</strong> Chat server with commands and proper message framing"[0m[37m,[0m
						[31m"<strong>Advanced:</strong> HTTP server passing basic performance tests (1000+ req/sec)"[0m[37m,[0m
						[31m"<strong>Expert:</strong> Server handles all error scenarios gracefully without crashes"[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üõ†Ô∏è"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"practice"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"practice"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"HANDS-ON EXERCISES"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Critical Error Handling"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"EAGAIN/EWOULDBLOCK - The Most Common Trap"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"Non-blocking sockets return these errors when they can't complete immediately. <strong>This is NOT an error!</strong>"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// WRONG - treating EAGAIN as fatal error
ssize_t result = recv(fd, buffer, size, 0);
if (result < 0) {
    perror("recv failed");  // Will spam errors!
    close(fd);
    return;
}

// CORRECT - handle EAGAIN properly
ssize_t result = recv(fd, buffer, size, 0);
if (result < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // No data available right now, try again later
        return;
    }
    // Only now it's a real error
    perror("recv failed");
    close(fd);
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"Partial Reads/Writes - Data Fragmentation"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"TCP can split your data into multiple packets. Never assume one call transfers everything!"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// WRONG - assumes all data is sent at once
char msg[] = "Hello, World!";
send(fd, msg, strlen(msg), 0);  // Might only send part!

// CORRECT - handle partial sends
size_t total_sent = 0;
size_t msg_len = strlen(msg);
while (total_sent < msg_len) {
    ssize_t sent = send(fd, msg + total_sent, msg_len - total_sent, 0);
    if (sent < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            // Socket buffer full, wait for POLLOUT
            break;
        }
        perror("send");
        return -1;
    }
    total_sent += sent;
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"Signal Interruption (EINTR)"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"System calls can be interrupted by signals. Always check for EINTR and retry."[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// Handle EINTR properly
while (1) {
    int ready = poll(fds, nfds, timeout);
    if (ready >= 0) {
        // Success
        break;
    }
    if (errno == EINTR) {
        // Interrupted by signal, retry
        continue;
    }
    // Real error
    perror("poll");
    return -1;
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Connection Management Pitfalls"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"<strong>Ghost connections:</strong> Always check POLLHUP/POLLERR and remove dead connections immediately."[0m[37m,[0m
								[31m"<strong>Buffer overflow:</strong> Malicious clients can send huge amounts of data. Always limit buffer sizes."[0m[37m,[0m
								[31m"<strong>Connection flooding:</strong> Accept() can return EMFILE (too many files) - handle gracefully."[0m[37m,[0m
								[31m"<strong>Memory leaks:</strong> Each connection allocates resources - ensure cleanup on disconnect."[0m
							[36m][0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Performance Traps"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"The Thundering Herd Problem"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// WRONG - accepting only one connection per poll
if (fds[0].revents & POLLIN) {
    int client = accept(server_fd, NULL, NULL);
    // Only handles one connection, others wait
}

// CORRECT - accept all available connections
if (fds[0].revents & POLLIN) {
    while (1) {
        int client = accept(server_fd, NULL, NULL);
        if (client < 0) {
            if (errno == EAGAIN) break;  // No more connections
            perror("accept");
            break;
        }
        // Handle new client...
    }
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"Poll Array Management"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"<strong>Fixed arrays:</strong> Don't use fixed-size arrays for thousands of connections."[0m[37m,[0m
								[31m"<strong>Gap management:</strong> When removing connections, avoid gaps in the array or poll() performance suffers."[0m[37m,[0m
								[31m"<strong>Event mask errors:</strong> Forgetting to set/unset POLLOUT when needed causes busy-waiting or missed writes."[0m
							[36m][0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Protocol-Level Issues"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"Message Boundary Problems"[0m[37m,[0m
							[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"heading"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"content"[0m[37m: [0m[31m"TCP is a stream protocol - it doesn't preserve message boundaries!"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"paragraph"[0m
						[36m}[0m[37m,[0m
						[36m{[0m
							[94m"code"[0m[37m: [0m[31m"// WRONG - assumes one recv() = one message
char buffer[1024];
recv(fd, buffer, sizeof(buffer), 0);
process_message(buffer);  // Might be partial or multiple messages!

// CORRECT - handle message framing
typedef struct {
    uint32_t length;  // Message length in network byte order
    char data[];      // Actual message data
} message_header_t;

// Read header first, then read exact amount of data
uint32_t msg_len;
if (recv_exactly(fd, &msg_len, sizeof(msg_len)) == sizeof(msg_len)) {
    msg_len = ntohl(msg_len);  // Convert from network byte order
    char *msg_data = malloc(msg_len);
    if (recv_exactly(fd, msg_data, msg_len) == msg_len) {
        process_message(msg_data, msg_len);
    }
    free(msg_data);
}"[0m[37m,[0m
							[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"codeblock"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Security Considerations"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"boxType"[0m[37m: [0m[31m"warning"[0m[37m,[0m
					[94m"content"[0m[37m: [0m[36m[[0m
						[36m{[0m
							[94m"items"[0m[37m: [0m[36m[[0m
								[31m"<strong>DoS via connection exhaustion:</strong> Limit concurrent connections per IP."[0m[37m,[0m
								[31m"<strong>Slowloris attacks:</strong> Set timeouts to disconnect slow/stalled clients."[0m[37m,[0m
								[31m"<strong>Buffer overflow attacks:</strong> Validate all input lengths before copying."[0m[37m,[0m
								[31m"<strong>Resource exhaustion:</strong> Monitor memory usage, set ulimits, implement rate limiting."[0m
							[36m][0m[37m,[0m
							[94m"type"[0m[37m: [0m[31m"list"[0m
						[36m}[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"actionbox"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"‚ö†Ô∏è"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"warnings"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"warnings"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"EDGE CASES & GOTCHAS"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Performance Optimization"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"When to Move Beyond Poll"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Poll has O(n) complexity per call. For high-performance servers (>1000 concurrent connections), consider these alternatives:"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>epoll (Linux):</strong> O(1) complexity, edge-triggered events, scales to hundreds of thousands of connections."[0m[37m,[0m
						[31m"<strong>kqueue (BSD/macOS):</strong> Similar to epoll, excellent performance on BSD systems."[0m[37m,[0m
						[31m"<strong>io_uring (Modern Linux):</strong> Asynchronous I/O with zero-copy operations."[0m[37m,[0m
						[31m"<strong>IOCP (Windows):</strong> Completion-based I/O for Windows servers."[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Epoll Migration Example"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"#ifdef __linux__
#include <sys/epoll.h>

// Create epoll instance
int epoll_fd = epoll_create1(EPOLL_CLOEXEC);

// Add server socket
struct epoll_event ev = {0};
ev.events = EPOLLIN | EPOLLET;  // Edge-triggered
ev.data.fd = server_fd;
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &ev);

// Main loop
struct epoll_event events[MAX_EVENTS];
while (1) {
    int nready = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    
    for (int i = 0; i < nready; i++) {
        if (events[i].data.fd == server_fd) {
            handle_new_connections();
        } else {
            handle_client_event(&events[i]);
        }
    }
}
#endif"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Architecture Patterns"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Single-threaded Event Loop"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Best for I/O-bound workloads. All events handled in one thread, no locking needed."[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// Redis/Node.js style - single event loop
void event_loop() {
    while (running) {
        int ready = poll(fds, nfds, 100);  // 100ms timeout
        
        // Handle I/O events
        handle_io_events(ready);
        
        // Process timer events
        process_timers();
        
        // Run scheduled callbacks
        run_callbacks();
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Multi-threaded Worker Pool"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"For CPU-intensive tasks or blocking operations."[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"// Main thread handles I/O, workers handle processing
typedef struct {
    int client_fd;
    char *request_data;
    size_t data_len;
} work_item_t;

// Main thread
if (fds[i].revents & POLLIN) {
    // Read request
    char buffer[4096];
    ssize_t len = recv(fds[i].fd, buffer, sizeof(buffer), 0);
    
    // Queue work for thread pool
    work_item_t *item = malloc(sizeof(work_item_t));
    item->client_fd = fds[i].fd;
    item->request_data = strdup(buffer);
    item->data_len = len;
    
    thread_pool_submit(item);
    
    // Remove from poll until response is ready
    fds[i].events &= ~POLLIN;
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Real-World Server Types"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"HTTP Server Implementation"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void handle_http_request(client_t *client) {
    // Parse HTTP request line
    char *method, *url, *version;
    if (parse_request_line(client->read_buffer, &method, &url, &version) < 0) {
        send_error_response(client, 400, "Bad Request");
        return;
    }
    
    // Handle different methods
    if (strcmp(method, "GET") == 0) {
        handle_get_request(client, url);
    } else if (strcmp(method, "POST") == 0) {
        handle_post_request(client, url);
    } else {
        send_error_response(client, 405, "Method Not Allowed");
    }
}

void send_http_response(client_t *client, int status, const char *body) {
    char response[4096];
    snprintf(response, sizeof(response),
        "HTTP/1.1 %d %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: keep-alive\r\n"
        "\r\n"
        "%s",
        status, status_text(status), strlen(body), body);
    
    // Queue response for sending
    queue_write_data(client, response, strlen(response));
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"WebSocket Server"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m4[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"code"[0m[37m: [0m[31m"void handle_websocket_frame(client_t *client) {
    ws_frame_t frame;
    if (parse_ws_frame(client->read_buffer, &frame) < 0) {
        close_client(client);
        return;
    }
    
    switch (frame.opcode) {
        case WS_OPCODE_TEXT:
            // Handle text message
            broadcast_to_all_clients(frame.payload, frame.payload_len);
            break;
            
        case WS_OPCODE_CLOSE:
            // Handle close frame
            send_ws_close(client);
            close_client(client);
            break;
            
        case WS_OPCODE_PING:
            // Send pong response
            send_ws_pong(client, frame.payload, frame.payload_len);
            break;
    }
}"[0m[37m,[0m
					[94m"language"[0m[37m: [0m[31m"c"[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"codeblock"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Monitoring & Debugging"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>Connection tracking:</strong> Log connect/disconnect events with timestamps and client info."[0m[37m,[0m
						[31m"<strong>Performance metrics:</strong> Track connections/second, bytes transferred, average response time."[0m[37m,[0m
						[31m"<strong>Error rates:</strong> Monitor EAGAIN frequency, connection drops, protocol errors."[0m[37m,[0m
						[31m"<strong>Resource usage:</strong> Watch file descriptor usage, memory per connection, CPU utilization."[0m[37m,[0m
						[31m"<strong>Tools:</strong> strace for system call debugging, netstat for connection states, wireshark for protocol analysis."[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"Prerequisites & Next Steps"[0m[37m,[0m
					[94m"level"[0m[37m: [0m[33m3[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"heading"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>Prerequisites:</strong> File descriptors, system calls, TCP/IP basics, C memory management."[0m[37m,[0m
						[31m"<strong>Related concepts:</strong> select(), epoll/kqueue, async I/O, thread pools, load balancing."[0m[37m,[0m
						[31m"<strong>Next steps:</strong> Study high-performance servers (nginx, Redis), protocol design, distributed systems."[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üîó"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"connections"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"connections"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"ADVANCED TOPICS & SCALING"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"What's the difference between poll() and busy-waiting on socket reads?"[0m[37m,[0m
						[31m"How do you handle a client disconnect in a poll-based server?"[0m[37m,[0m
						[31m"Why might poll() return without any file descriptors being ready?"[0m
					[36m][0m[37m,[0m
					[94m"ordered"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m[37m,[0m
				[36m{[0m
					[94m"content"[0m[37m: [0m[31m"<strong>Success criteria:</strong> You can build a multi-client server that doesn't waste CPU cycles.<br><strong>Review triggers:</strong> When building any networked application or real-time system."[0m[37m,[0m
					[94m"html"[0m[37m: [0m[32mtrue[0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"paragraph"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üéØ"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"test"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"test"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"TEST YOURSELF"[0m
		[36m}[0m[37m,[0m
		[36m{[0m
			[94m"content"[0m[37m: [0m[36m[[0m
				[36m{[0m
					[94m"items"[0m[37m: [0m[36m[[0m
						[31m"<strong>This week:</strong> Build an echo server, then a simple chat server using poll."[0m[37m,[0m
						[31m"<strong>This month:</strong> Learn epoll (Linux) or kqueue (BSD) for higher performance."[0m[37m,[0m
						[31m"<strong>Long term:</strong> Master async programming patterns, protocol design, and high-concurrency architectures."[0m
					[36m][0m[37m,[0m
					[94m"type"[0m[37m: [0m[31m"list"[0m
				[36m}[0m
			[36m][0m[37m,[0m
			[94m"emoji"[0m[37m: [0m[31m"üìà"[0m[37m,[0m
			[94m"iconClass"[0m[37m: [0m[31m"growth"[0m[37m,[0m
			[94m"id"[0m[37m: [0m[31m"growth"[0m[37m,[0m
			[94m"title"[0m[37m: [0m[31m"LEVEL UP"[0m
		[36m}[0m
	[36m][0m
[36m}[0m
